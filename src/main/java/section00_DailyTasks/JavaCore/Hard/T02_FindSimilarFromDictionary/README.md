Наверняка тебе знакомо сообщение от Google "Возможно, вы имели в виду ...?", когда вводишь
поисковый запрос и ошибаешься в слове. В этой задаче мы хотим реализовать нечто подобное.

Ты получишь введенный термин`term`(строка в нижнем регистре) и массив известных слов`words`(также
строки в нижнем регистре). Твоя задача - выяснить, какое слово из словаря наиболее похоже на
введенное. Сходство описывается минимальным количеством букв, которые нужно добавить, убрать или
заменить, чтобы перейти от введенного слова к одному из словаря.

Чем меньше количество необходимых изменений, тем выше сходство между двумя словами. Одинаковые
слова, очевидно, являются наиболее похожими.

Слово, в котором нужно изменить одну букву, более похоже на другое слово, в котором нужно изменить
2 (или более) буквы. Например, ошибочный термин`berr`больше похож на`beer`(нужно заменить 1 букву),
чем на`barrel`(всего нужно заменить 3 буквы).

Подсказка: посмотри алгоритм`Levenshtein distance`.

Примеры:

```
Dictionary fruits = new Dictionary(new String[]{"cherry", "pineapple", "melon", "strawberry", "raspberry"});
fruits.findMostSimilar("strawbery"); // возвращает "strawberry"
fruits.findMostSimilar("berry"); // возвращает "cherry"

Dictionary things = new Dictionary(new String[]{"stars", "mars", "wars", "codec", "codewars"});
things.findMostSimilar("coddwars"); // возвращает "codewars"

Dictionary languages = new Dictionary(new String[]{"javascript", "java", "ruby", "php", "python", "coffeescript"});
languages.findMostSimilar("heaven"); // возвращает "java"
languages.findMostSimilar("javascript"); // возвращает "javascript" (одинаковые слова являются наиболее похожими)
```

Примечания:

- в этой задаче строка`java`более похожа на`heaven`, чем все остальные.
- всегда существует ровно один возможный правильный вариант